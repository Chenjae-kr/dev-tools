<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PDF to Image Converter | Dev Tools</title>
<script src="../../tools.js"></script>
<script src="../../nav.js"></script>
<script src="../../ui-utils.js"></script>
<script src="../../image-tools-utils.js"></script>
<script src="../../vendor/jszip.min.js"></script>
<link rel="stylesheet" href="../../styles.css">
<style>
.preview-wrap{position:sticky;top:84px}
.pdf-canvas{width:100%;height:auto;border:1px solid var(--border);border-radius:10px;background:#fff}
@media(max-width:980px){.preview-wrap{position:static;top:auto}}
</style>
</head>
<body>
<script>renderNav();</script>
<div class="container">
  <div class="tool-header"><h1>PDF → Image Converter</h1><p>// PDF 페이지를 이미지(PNG/JPG/WEBP)로 변환</p></div>
  <div class="main-grid">
    <div>
      <div class="panel">
        <div class="panel-header"><div class="panel-title"><div class="dot"></div>SETTINGS</div></div>

        <div class="setting-group">
          <div class="setting-title">Source</div>
          <div class="options-bar row-tight">
            <span class="options-label">PDF</span>
            <input id="pdfFile" type="file" accept="application/pdf,.pdf">
          </div>
        </div>

        <div class="setting-group">
          <div class="setting-title">Render</div>
          <div class="options-bar row-tight">
            <span class="options-label">Page</span>
            <button class="toggle-btn" onclick="prevPage()">◀</button>
            <input id="pageNum" class="table-name-input input-xs" type="number" min="1" value="1">
            <span id="pageTotal" class="options-label">/ 0</span>
            <button class="toggle-btn" onclick="nextPage()">▶</button>
          </div>
          <div class="options-bar row-tight">
            <span class="options-label">Scale%</span>
            <input id="scale" class="table-name-input input-xs" type="number" min="50" max="400" value="150">
            <span class="options-label">Format</span>
            <div class="toggle-group">
              <button class="toggle-btn fmt active" data-fmt="png">PNG</button>
              <button class="toggle-btn fmt" data-fmt="jpeg">JPG</button>
              <button class="toggle-btn fmt" data-fmt="webp">WEBP</button>
            </div>
            <span class="options-label">Quality</span>
            <input id="quality" class="table-name-input input-xs" type="number" min="1" max="100" value="92">
          </div>
          <div class="options-bar row-tight">
            <span class="options-label">Range</span>
            <input id="pageRange" class="table-name-input" placeholder="예: 1-3,5" value="all">
          </div>
          <div class="download-actions">
            <button class="toggle-btn download-btn single" onclick="downloadCurrent()">⬇ 현재 페이지 다운로드</button>
            <button class="toggle-btn download-btn all" onclick="downloadRangeZip()">⬇ 범위 ZIP 다운로드</button>
            <button class="toggle-btn download-btn all full" onclick="downloadAll()">⬇ 전체 ZIP 다운로드</button>
          </div>
          <div class="options-bar row-tight">
            <span id="zipProgress" class="options-label"></span>
          </div>
        </div>
      </div>
    </div>

    <div class="preview-wrap">
      <div class="panel">
        <div class="panel-header"><div class="panel-title"><div class="dot"></div>PREVIEW</div></div>
        <canvas id="pdfCanvas" class="pdf-canvas" width="1080" height="1350"></canvas>
      </div>
    </div>
  </div>
  <footer>// PDF to Image Converter</footer>
</div>

<script type="module">
import * as pdfjsLib from '../../vendor/pdfjs/pdf.min.mjs';
pdfjsLib.GlobalWorkerOptions.workerSrc = '../../vendor/pdfjs/pdf.worker.min.mjs';

let pdfDoc = null;
let currentPage = 1;
let fmt = 'png';
const canvas = document.getElementById('pdfCanvas');
const ctx = canvas.getContext('2d');

document.querySelectorAll('.fmt').forEach(b=>b.addEventListener('click',()=>{
  document.querySelectorAll('.fmt').forEach(x=>x.classList.remove('active'));
  b.classList.add('active');
  fmt = b.dataset.fmt;
}));

document.getElementById('pdfFile').addEventListener('change', async (e)=>{
  const f = e.target.files?.[0];
  if (!f) return;
  const arr = await f.arrayBuffer();
  pdfDoc = await pdfjsLib.getDocument({ data: arr }).promise;
  currentPage = 1;
  document.getElementById('pageNum').value = 1;
  document.getElementById('pageTotal').textContent = `/ ${pdfDoc.numPages}`;
  renderCurrent();
});

document.getElementById('pageNum').addEventListener('change', () => { if (pdfDoc) renderCurrent(); });
document.getElementById('scale').addEventListener('change', () => { if (pdfDoc) renderCurrent(); });

async function renderPage(pageNum){
  if (!pdfDoc) return;
  const page = await pdfDoc.getPage(pageNum);
  const scale = Math.max(0.5, Math.min(4, Number(document.getElementById('scale').value || 150)/100));
  const viewport = page.getViewport({ scale });
  canvas.width = Math.floor(viewport.width);
  canvas.height = Math.floor(viewport.height);
  await page.render({ canvasContext: ctx, viewport }).promise;
}

window.renderCurrent = async function(){
  if (!pdfDoc) { alert('PDF 파일을 먼저 선택하세요.'); return; }
  const p = Math.max(1, Math.min(pdfDoc.numPages, Number(document.getElementById('pageNum').value || currentPage)));
  currentPage = p;
  document.getElementById('pageNum').value = p;
  await renderPage(p);
};

window.prevPage = function(){
  if (!pdfDoc) return;
  if (currentPage > 1) { currentPage--; document.getElementById('pageNum').value = currentPage; renderCurrent(); }
};
window.nextPage = function(){
  if (!pdfDoc) return;
  if (currentPage < pdfDoc.numPages) { currentPage++; document.getElementById('pageNum').value = currentPage; renderCurrent(); }
};

window.downloadCurrent = function(){
  if (!pdfDoc) return;
  const q = Math.max(1, Math.min(100, Number(document.getElementById('quality').value || 92)))/100;
  ImageToolUtils.downloadCanvas(canvas, { format: fmt, quality: q, filename: `pdf_p${currentPage}` });
};

function parsePageRange(input, maxPages){
  const text = String(input || 'all').trim().toLowerCase();
  if (!text || text === 'all') return Array.from({length:maxPages}, (_,i)=>i+1);
  const set = new Set();
  const invalid = [];
  text.split(',').map(x=>x.trim()).filter(Boolean).forEach(part => {
    if (part.includes('-')) {
      const [a,b] = part.split('-').map(v => parseInt(v.trim(),10));
      if (Number.isFinite(a) && Number.isFinite(b)) {
        const s = Math.max(1, Math.min(a,b));
        const e = Math.min(maxPages, Math.max(a,b));
        for (let i=s;i<=e;i++) set.add(i);
      } else invalid.push(part);
    } else {
      const n = parseInt(part,10);
      if (Number.isFinite(n) && n>=1 && n<=maxPages) set.add(n);
      else invalid.push(part);
    }
  });
  const out = [...set].sort((x,y)=>x-y);
  if (!out.length) throw new Error('유효한 페이지 범위를 찾을 수 없습니다. 예: 1-3,5');
  if (invalid.length) throw new Error(`잘못된 범위: ${invalid.join(', ')}`);
  return out;
}

function canvasBlob(type, quality){
  return new Promise((resolve) => canvas.toBlob(resolve, type, quality));
}

async function downloadZipForPages(pages){
  if (!pdfDoc || !pages.length) return;
  const progressEl = document.getElementById('zipProgress');
  const q = Math.max(1, Math.min(100, Number(document.getElementById('quality').value || 92)))/100;
  const mime = fmt === 'png' ? 'image/png' : fmt === 'webp' ? 'image/webp' : 'image/jpeg';
  const ext = fmt === 'jpeg' ? 'jpg' : fmt;
  const zip = new JSZip();
  const keep = currentPage;
  let idx = 0;

  for (const p of pages) {
    idx += 1;
    if (progressEl) progressEl.textContent = `ZIP 생성중 ${idx}/${pages.length}`;
    currentPage = p;
    document.getElementById('pageNum').value = p;
    await renderPage(p);
    const blob = await canvasBlob(mime, q);
    if (blob) zip.file(`pdf_p${p}.${ext}`, blob);
  }

  if (progressEl) progressEl.textContent = 'ZIP 압축중...';
  const content = await zip.generateAsync({ type: 'blob' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(content);
  a.download = `pdf_pages_${Date.now()}.zip`;
  a.click();
  URL.revokeObjectURL(a.href);

  currentPage = keep;
  document.getElementById('pageNum').value = keep;
  await renderPage(keep);
  if (progressEl) progressEl.textContent = '';
}

window.downloadRangeZip = async function(){
  if (!pdfDoc) return;
  try {
    const pages = parsePageRange(document.getElementById('pageRange').value, pdfDoc.numPages);
    await downloadZipForPages(pages);
  } catch (e) {
    alert(e.message || '유효한 페이지 범위를 입력하세요.');
  }
};

window.downloadAll = async function(){
  if (!pdfDoc) return;
  const pages = Array.from({length: pdfDoc.numPages}, (_,i)=>i+1);
  await downloadZipForPages(pages);
};
</script>
</body>
</html>